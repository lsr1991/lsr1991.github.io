---
layout: post
title: Scala中的隐式转换(Part1)
comments: true
---

---

本文选译自[《Programming in Scala》第21章](http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html)。

---

### 1. 隐式转换和隐式参数

在你自己的代码和其他人的库之间有一种根本性的不同：你可以随意改变你自己的代码，但如果你想使用他人的库，你通常必须照着这些库已有的样子来使用。

编程语言中有一些设计被用于缓解这个问题。Ruby拥有module，Smalltalk让包添加到各自的类中。这些是很强大的，但也很危险，因为你修改了一个类的行为，这个类是面向整个应用的，而应用中某些地方可能是你不清楚的。C# 3.0拥有静态扩展方法，这是更本地化的，但也更加严格，因为你只能够向一个类添加方法，不能添加字段（或称域），你也不能让一个类实现新的接口。

scala的答案是隐式转换和隐式参数。这个方案能够你更愉快地处理已存在的库，它让你不用考虑冗长的、平淡无奇的细节，这些细节会使你代码的关键部分变得不清晰和难以理解。优雅地使用，这让你的代码只关注你的程序中重要的部分。这一章展示隐式转换和隐式参数如何工作，以及它们最常见的使用方式。

#### 1.1. 隐式转换

RandomAccessSeq[T]描述了元素类型为T的随机访问序列，它拥有大多数适用于数组和列表的方法，如take、drop、map、filter等等。为了创建一个新的随机访问序列，你只需要继承trait RandomAccessSeq[T]。你只需要定义在trait中的两个方法：length和apply。然后你可以“免费”使用这个trait里面的多个方法实现。

但是这只在你定义新类的时候有用，如果类是已经存在的呢？可能你想要将别人库里面的类也弄成随机访问序列，甚至那些库的设计者都没这样想过。比如，一个Java中的String对象可以做成一个RandomAccessSeq[Char]类型，但是Java中的String类并没有继承RandomAccessSeq。

在这种场景中，隐式转换就派上用场了。为了让String类型成为RandomAccessSeq的一个子类型，你可以定义一个隐式转换，它负责将一个String对象转换成一个适配器类，该类是RandomAccessSeq的一个子类：

```scala
implicit def stringWrapper(s: String) = 
  new RandomAccessSeq[Char] {
  def length = s.length
  def apply(i: Int) = s.charAt(i)
}
```

这个隐式转换只是一个常规的函数。特别的只有一件事：定义开头的implicit修饰语。你可以显式地应用这个转换函数来将String对象转换成RandomAccessSeq。

```shell
scala> stringWrapper("abc123") exists (_.isDigit)
res0: Boolean = true
```

但你也可以不考虑这个转换，仍然得到相同的结果：

```scala
scala> "abc123" exists (_.isDigit)
res1: Boolean = true
```

这里背后的机制是scala编译器为你插入stringWrapper转换。因此它将上面的表达式重写显式转换的表达式。但是从表面上看来，Java的String对象都就拥有了trait RandomAccessSeq中所有有用的方法。

implicit方法的样子跟C#中的扩展方法是相似的，它允许你对已存在的类添加新方法。然而，隐式方法可以比扩展方法做得更精确。例如，在stringWrapper转换中，我们只需要定义length和apply方法，然后就可以得到所有在RandomAccessSeq中的方法。而使用扩展方法时你需要再次定义所有这些方法。这个复制过程使得代码更难写，并且，更重要的是，更难维护。想象一下某一天有人往RandomAccessSeq中添加一个新的方法。如果你只能够使用扩展方法，你就必须一个一个地找出所有的RandomAccessSeq的复制品，然后往里面添加这个别人添加进去的新方法。如果你忘记其中一个复制品，你的系统将变得不一致。这对于软件维护来说将是一个噩梦。相反，通过scala的隐式转换，所有转换都将自动载入新加入的方法。

隐式转换的另一个优点是它们支持转换到特定类型，这个类型可能是代码中会用到的。例如，假设你写一个方法printWithSpaces，它将一个给定的随机访问序列中的所有字符以空格隔开并打印出来：

```scala
def printWithSpaces(seq: RandomAccessSeq[Char]) = 
seq mkString " "
```

因为字符串是隐式可转换为RandomAccessSeq，你可以将一个String对象传递给printWithSpaces：

```shell
scala> printWithSpaces("xyz")
res2: String = x y z
```

这一节为你展示了隐式转换的一些能力，以及它们如何让你装饰现有库。在下一节你将学习隐式转换是什么时候发生的，以及它们是如何被找到的。

#### 1.2. 隐式转换的规则

隐式定义是指那些为了修复类型错误而被编译器插入到程序中的代码。例如，如果x+y没有类型检查，那么编译器可以能会将它修改为convert(x)+y，其中convert是某个可用的隐式转换。如果convert将x改变为某些拥有+方法的对象，那么这个改变将修复了一个程序，所以程序可以进行类型检查并正确地运行。如果convert真的只是一个简单地转换函数，那么让它位于源代码外部可以让代码变得更清晰。

隐式转换由以下规则控制：

- 标识规则：只有定义中标识有implicit才是可用的。

implicit关键词被用于告诉编译器哪些定义可以当作隐式转换来使用。你可以使用它来标识任何变量、函数或者对象定义。下面是一个隐式函数定义：

```scala
implicit def intToString(x: Int) = x.toString
```

编译器将只在convert被标识为隐式的时候才会把x+y改变为convert(x)+y。通过这种方式，你避免了一种歧义：这种歧义会导致编译器从当前作用域中随机选取一个函数作为转换函数。编译器将只会选择那些你标识为隐式的那些定义。

- 作用域规则：一个被插入的隐式转换必须在当前作用域内是一个单一标识符，或者与转换中的源类型、目标类型其中之一相关。

scala编译器将只考虑当前作用域的隐式转换。为了使一个隐式转换可用，你必须通过某种方式将其引入当前作用域。此外，隐式转换还必须是当前作用域内的一个单一标识符。编译器不会将形如someVariable.convert的转换插入到代码中。例如，它将不会扩展x+y为someVariable.convert(x) + y。如果你想要让someVariable.convert可用作一个隐式转换，那么你需要把它import进来，这样才能将它变为一个单一标识符。一旦import之后，编译器将可以把它用作convert(x) + y。事实上，库通常都会包含一个Preamble对象，它包含了一些有用的隐式转换。使用那些库的代码可以通过`import Preamble._`来使库中的隐式转换可以被访问。

但对于单一标识符规则来说，有一个例外。编译器还会在转换的源类型或者目标类型的伴生对象中寻找隐式定义。例如，如果你尝试将一个Dollar对象传递给一个接收Euro对象的方法，源类型是Doller，目标类型是Euro。你将可以把一个从Dollar到Euro的隐式转换放到Dollar和Euro类任意一个中的伴生对象里面。下面是一个例子，在Dollar的伴生对象中定义了一个隐式转换：

```scala
object Dollar {
  implicit def dollarToEuro(x: Dollar): Euro = ...
}
class Dollar { ... }
```

在这个例子中，转换dollarToEuro被称为与类型Dollar相关联。当编译器每次需要从一个Dollar类型的实例来转换时，它将会找到一个关联的转换。因此没有必要另外import那些隐式转换到你的程序中。

作用域规则有助于模块推导。当你阅读一个文件中的代码时，在从外部文件导入的东西里面，你只需要考虑那些import进来的或者指定全限定名的显式引用。这种好处对于隐式转换和显式代码来说都是重要的。如果隐式转换作用于系统范围，那么为了理解一个文件，你将必须知道程序中引入的任何一个隐式转换是从哪里来的。

- 无歧义规则：一个隐式转换只能在没有其他可能的转换时被插入。

如果编译器拥有两个选择来修复x+y，如使用convert1(x)+y或者convert2(x)+y，那么它将会报错并拒绝在二者间作出选择。定义“最佳匹配”规则来决定哪些转换具有优先权是可能的。然而，这种选择会导致代码难以理解。想象一下编译器选择了convert2，但是你刚接触这个文件，并只知道convert1，那么你会在很长一段时间内认为被应用的隐式转换是convert1。

在像上面的这个例子中，一个选择是将其中一个隐式转换给移除掉，另一个选择是显式指定转换：convert2(x) + y。

- 一次只转一个规则：只会尝试一个隐式转换。

编译器不会将x+y重写为convert1(convert2(x)) + y。这样做会导致错误代码的编译的时间剧烈增加，并且它会让程序员所写的和程序真正做的更加不一样。明智地，编译器在进行一个隐式转换的尝试时不会插入更多的隐式转换。然而，要绕过这个限制是可能的：让隐式转换接收隐式参数，这在之后的小节会讲。

- 显式优先规则：无论何时代码如它所写进行了类型检查，那么没有隐式转换会被执行。

编译器将不会改变任何已经可以运行的代码。这条规则的推论是你可以总是将隐式标识符换成显式的，这样会使得代码更长但却更明白。你可以在这些选择之间进行权衡。当代码看起来重复而冗长时，隐式转换就可以帮助你减少这些单调乏味的代码。当代码看起来难以理解时，你可以显式地插入转换。你留给编译器插入的隐式转换的数量最终只是代码的一种风格。

命名一个隐式转换。隐式转换可以有任意名字。一个隐式转换的名字只在两种场景要会用到：如果你想要在一个方法应用中显式写出转换；在程序的任意位置决定哪些隐式转换是可用的。

为了解释第二点，假设你有一个单例对象，它有两个隐式转换：

```scala
object MyConversions {
  implicit def stringWrapper(s: String):
  RandomAccessSeq[Char] = ...
  implicit def intToString(x: Int): String = ...
}
```

在你的应用中，你想要使用stringWrapper转换，但是你不想要整数被intToString自动转换为字符串。你可以通过只导入一个转换来实现：

```scala
import MyConversions.stringWrapper
... // code making use of stringWrapper
```

在这个例子中，隐式转换有名字是重要的，因为只有这样你才能有选择地导入一个指定的转换而不会导入另一个不希望用到的。

隐式转换在哪里会被尝试执行。在语言中有三个地方使用了隐式转换：转换到一个目标类型；一个选择器的接收参数的转换；隐式参数。隐式转换为一个目标类型让你可以在上下文中使用一个与目标类型不同的类型。接收者的转换让你发送消息给一个的接收者（即调用它的方法）时可以对接收者进行转换，比如，一个对象被调用了一个方法，该方法却不存在于这个对象的类中。一个例子是`"abc".exists`，它被转换为`stringWrapper("abc").exists`，因为exists方法不存在于String对象中，但在RandomAccessSeq对象中就可用。另一方面，隐式参数通常被用于给被调用的函数提供更多关于调用者要做什么的信息。隐式参数对于通用函数来说尤为有用，通用函数可能不知道一个或多个参数的类型。下面三节将会讨论这三种类型的隐式转换。
